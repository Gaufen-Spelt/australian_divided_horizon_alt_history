title: Post Event
new-page: true
on-arrival: {!


console.log('=== POST EVENT START ===');
console.log('Actions at entry:', Q.actions);
console.log('Day:', Q.day, 'Week:', Q.week, 'Month:', Q.month);

// ============================================
// INITIALIZE AND INCREMENT ACTIONS
// ============================================
Q.actions = (Q.actions || 0);
Q.last_advisor_action = 0;
Q.last_cabinet_action = 0;

// ============================================
// SANITIZE CLASS-PARTY SUPPORT (no negatives)
// ============================================
for (let c of Q.classes) {
    for (let party of Q.parties) {
        Q[c + '_' + party] = Math.max(0, Q[c + '_' + party] || 0);
    }
}

// ============================================
// SANITIZE OPINION VARIABLES
// ============================================
Q.pro_republic = Math.max(0, Math.min(99, Math.round(Q.pro_republic || 0)));
Q.nationalism = Math.max(0, Math.min(100, Math.round(Q.nationalism || 0)));
Q.socialism = Math.max(0, Math.min(100, Math.round(Q.socialism || 0)));

// ============================================
// CALCULATE NORMALIZED CLASS VOTING
// ============================================
for (let c of Q.classes) {
    let class_votes = 0;
    
    // Sum total votes for this class
    for (let party of Q.parties) {
        class_votes += Q[c + '_' + party];
    }
    
    // Normalize to percentages
    for (let party of Q.parties) {
        if (class_votes > 0) {
            Q[c + '_' + party + '_normalized'] = 100 * Q[c + '_' + party] / class_votes;
            Q[c + '_' + party + '_display'] = Math.round(100 * Q[c + '_' + party] / class_votes);
        } else {
            Q[c + '_' + party + '_normalized'] = 0;
            Q[c + '_' + party + '_display'] = 0;
        }
    }
}

// ============================================
// CALCULATE OVERALL PARTY SUPPORT
// ============================================
let total_support = 0;

for (let party of Q.parties) {
    let party_support = 0;
    
    for (let c of Q.classes) {
        if (Q.old_demographics) {
            party_support += Q[c] * Q[c + '_' + party];
        } else {
            party_support += Q[c] * Q[c + '_' + party + '_normalized'];
        }
    }
    
    Q[party + '_support'] = party_support;
    total_support += party_support;
}

// Normalize party support to percentages
for (let party of Q.parties) {
    if (total_support > 0) {
        Q[party + '_normalized'] = Q[party + '_support'] / total_support;
        Q[party + '_votes'] = Math.round(Q[party + '_normalized'] * 100);
        Q[party + '_votes_display'] = Math.round(Q[party + '_normalized'] * 100).toFixed(2);
    } else {
        Q[party + '_normalized'] = 0;
        Q[party + '_votes'] = 0;
        Q[party + '_votes_display'] = 0.0;
    }
}

// ============================================
// NORMALIZE FACTIONS (sum to 200)
// ============================================
let factions = [
    'left_vic', 'left_nsw', 'centre_federal', 'centre_unity',
    'right_alp_nsw', 'right_alp_qld', 'right_alp_south', 'right_alp_union',
    'groupers'
];

if (Q.langist_strength > 0) {
    factions.push('langist');
}

let faction_sum = 0;
for (let f of factions) {
    Q[f + '_strength'] = Math.max(0, Q[f + '_strength'] || 0);
    faction_sum += Q[f + '_strength'];
}

if (faction_sum > 0) {
    let faction_factor = 200 / faction_sum;
    for (let f of factions) {
        Q[f + '_strength'] = +((Q[f + '_strength'] * faction_factor).toFixed(2));
    }
}

// Sanitize faction dissent
for (let f of factions) {
    Q[f + '_dissent'] = Math.max(0, Math.min(99, Q[f + '_dissent'] || 0));
}

// ============================================
// CALCULATE OVERALL DISSENT
// ============================================
let total_dissent = 0;
let total_strength = 0;

for (let f of factions) {
    total_dissent += (Q[f + '_dissent'] || 0) * (Q[f + '_strength'] || 0);
    total_strength += Q[f + '_strength'] || 0;
}

if (total_strength > 0) {
    Q.dissent = total_dissent / total_strength / 100;
} else {
    Q.dissent = 0;
}
Q.dissent = Math.max(0, Math.min(0.95, Q.dissent));
Q.dissent_percent = Q.dissent * 100;

// ============================================
// NORMALIZE CLASSES (sum to 100)
// ============================================
let classes = [
    'workers', 'white_collar', 'business', 'rural', 'unemployed',
    'catholics', 'migrants'
];

let class_sum = 0;
for (let c of classes) {
    Q[c] = Math.max(0, Q[c] || 0);
    class_sum += Q[c];
}

if (class_sum > 0) {
    let class_factor = 100 / class_sum;
    for (let c of classes) {
        Q[c] = +((Q[c] * class_factor).toFixed(2));
    }
}

// ============================================
// RECALCULATE NORMALIZED CLASS VOTES (with dynamic parties)
// ============================================
let parties = [
'alp', 'liberal', 'country, 'cpa', 'other'
];

if (Q.dlp_formed) {
    parties.push('dlp');
}
if (Q.lang_labor_active) {
    parties.push('lang');
}
parties.push('other');

for (let c of classes) {
    let class_votes = 0;

    // Sum all party support for this class
    for (let party of parties) {
        Q[c + '_' + party] = Math.max(0, Q[c + '_' + party] || 0);
        class_votes += Q[c + '_' + party];
    }

    // Normalize and create display values
    for (let party of parties) {
        if (class_votes > 0) {
            Q[c + '_' + party + '_normalized'] = Q[c + '_' + party] / class_votes;
            Q[c + '_' + party + '_display'] = (Q[c + '_' + party + '_normalized'] * 1000).toFixed(1);
        } else {
            Q[c + '_' + party + '_normalized'] = 0;
            Q[c + '_' + party + '_display'] = '0';
        }
    }
}

// ============================================
// SANITIZE ECONOMIC VARIABLES
// ============================================
Q.unemployed = Math.max(1, Q.unemployed || 1);
Q.inflation = Q.inflation || 0;

// ============================================
// MULTI-SCALE TIME QUEUE SYSTEM
// ============================================

// Initialize time queues
Q.day_actions   = Q.day_actions   || 0;
Q.week_actions  = Q.week_actions  || 0;
Q.month_actions = Q.month_actions || 0;

// Initialize calendar
Q.day   = Q.day   || 1;
Q.week  = Q.week  || 1;
Q.month = Q.month || 1;
Q.year  = Q.year  || 1949;
Q.time  = Q.time  || 0;

// ============================================
// ADVANCE DAY
// ============================================
function advance_day() {

    Q.day += 1;
    Q.time += 0.036;   // â‰ˆ 1 / 28

    // Decrement daily timers
    for (let t of Q.daily_timers || []) {
        if (Q[t + '_timer'] > 0) Q[t + '_timer'] -= 1;
    }

    // Weekly rollover
    if (Q.day >= 8) {
        Q.day = 1;
        Q.week_actions += 1;   // queue a week tick
    }
}

// ============================================
// ADVANCE WEEK
// ============================================
function advance_week() {

    Q.week += 1;
    Q.time += 0.25;

    // Decrement weekly timers
    for (let t of Q.weekly_timers || []) {
        if (Q[t + '_timer'] > 0) Q[t + '_timer'] -= 1;
    }

    // Monthly rollover
    if (Q.week >= 5) {
        Q.week = 1;
        Q.month_actions += 1;   // queue a month tick
    }
}

// ============================================
// ADVANCE MONTH
// ============================================
function advance_month() {

    Q.month += 1;
    Q.time += 1;

    // Year rollover
    if (Q.month >= 13) {
        Q.month = 1;
        Q.year += 1;

        if (Q.historical_mode) Q.resources += 2;
    }

    // Decrement monthly timers
    for (let t of Q.timers || []) {
        if (Q[t + '_timer'] > 0) Q[t + '_timer'] -= 1;
    }

    // Record statistics
    Q.party_support_records = Q.party_support_records || [];
    Q.economic_records = Q.economic_records || [];

    let date = new Date(Q.year, Q.month - 1);

    let party_row = { date };
    for (let p of Q.parties) {
        party_row[p] = Q[p + '_normalized'] * 100;
    }
    Q.party_support_records.push(party_row);

    Q.economic_records.push({
        date,
        inflation: Q.inflation,
        unemployment: Q.unemployed
    });
}

// ============================================
// PROCESS TIME QUEUES
// ============================================

while (Q.day_actions >= 1) {
    Q.day_actions -= 1;
    advance_day();
}

while (Q.week_actions >= 1) {
    Q.week_actions -= 1;
    advance_week();
}

while (Q.month_actions >= 1) {
    Q.month_actions -= 1;
    advance_month();
}
// ============================================
// CHECK FOR EVENTS
// ============================================
Q.has_event = 0;
let scene = this.game.scenes['post_event.events_choice'];
let choices = this._compileChoices(scene);

if (choices && choices[0].title != "Continue...") {
    Q.has_event = 1;
}

// Pre-load event images
if (this.ui && this.ui.show_portraits) {
    for (let choice of choices) {
        let cc = this.game.scenes[choice.id];
        if (cc.faceImage) {
            let im = new Image();
            im.src = cc.faceImage;
        }
    }
}

!}
go-to: events_choice if has_event = 1; main if has_event = 0 and use_main_2 = 0 and difficulty >= 0; main.main_easy if has_event = 0 and use_main_2 = 0 and difficulty < 0; main_2 if has_event = 0 and use_main_2 = 1

= Day [+ day +], Week [+ week +], [+ month : month +] [+ year +]

@events_choice

- #event
